{"name":"Bridge","tagline":"A simple but powerful HTTP networking library for Android. It features a Fluent chainable API, powered by Java/Android's URLConnection classes for maximum compatibility and speed.","body":"# Bridge\r\n\r\nBridge is a simple but powerful HTTP networking library for Android. It features a Fluent chainable API,\r\npowered by Java/Android's URLConnection classes for maximum compatibility and speed.\r\n\r\n# Table of Contents\r\n\r\n### Traditional\r\n\r\n1. [Gradle Dependency](https://github.com/afollestad/bridge#gradle-dependency)\r\n\t1. [Repository](https://github.com/afollestad/bridge#repository)\r\n\t2. [Dependency](https://github.com/afollestad/bridge#dependency)\r\n2. [Requests](https://github.com/afollestad/bridge#requests)\r\n\t1. [Request Basics](https://github.com/afollestad/bridge#request-basics)\r\n\t2. [Request Headers](https://github.com/afollestad/bridge#request-headers)\r\n\t3. [Request Bodies](https://github.com/afollestad/bridge#request-bodies)\r\n\t\t1. [Plain Bodies](https://github.com/afollestad/bridge#plain-bodies)\r\n\t\t2. [Form Bodies](https://github.com/afollestad/bridge#plain-bodies)\r\n\t\t3. [MultipartForm Bodies](https://github.com/afollestad/bridge#plain-bodies)\r\n\t4. [Streaming Bodies](https://github.com/afollestad/bridge#plain-bodies)\r\n\t4. [Info Callbacks](https://github.com/afollestad/bridge#info-callbacks)\r\n3. [Responses](https://github.com/afollestad/bridge#responses)\r\n\t1. [Response Basics](https://github.com/afollestad/bridge#response-basics)\r\n\t2. [Response Bodies](https://github.com/afollestad/bridge#response-bodies)\r\n4. [Error Handling](https://github.com/afollestad/bridge#error-handling)\r\n5. [Async](https://github.com/afollestad/bridge#async)\r\n\t1. [Async Requests](https://github.com/afollestad/bridge#async-requests)\r\n\t2. [Duplicate Avoidance](https://github.com/afollestad/bridge#duplicate-avoidance)\r\n\t3. [Upload Progress](https://github.com/afollestad/bridge#upload-progress)\r\n\t4. [Download Progress](https://github.com/afollestad/bridge#download-progress)\r\n6. [Request Cancellation](https://github.com/afollestad/bridge#request-cancellation)\r\n\t1. [Cancelling Single Requests](https://github.com/afollestad/bridge#cancelling-single-requests)\r\n\t2. [Cancelling Multiple Requests](https://github.com/afollestad/bridge#cancelling-multiple-requests)\r\n\t3. [Preventing Cancellation](https://github.com/afollestad/bridge#preventing-cancellation)\r\n7. [Validation](https://github.com/afollestad/bridge#validation)\r\n8. [Configuration](https://github.com/afollestad/bridge#configuration)\r\n\t1. [Host Configuration](https://github.com/afollestad/bridge#host-configuration)\r\n\t2. [Default Headers](https://github.com/afollestad/bridge#default-headers)\r\n\t3. [Timeout Configuration](https://github.com/afollestad/bridge#timeout-configuration)\r\n\t4. [Buffer Size](https://github.com/afollestad/bridge#buffer-size)\r\n\t5. [Logging](https://github.com/afollestad/bridge#logging)\r\n\t6. [Global Validators](https://github.com/afollestad/bridge#global-validators)\r\n9. [Cleanup](https://github.com/afollestad/bridge#cleanup)\r\n\r\n### Conversion\r\n\r\n1. [Request Conversion](https://github.com/afollestad/bridge#request-conversion)\r\n\t1. [JSON Request Conversion](https://github.com/afollestad/bridge#json-request-conversion)\r\n\t2. [Dot Notation](https://github.com/afollestad/bridge#dot-notation)\r\n\t3. [Request Conversion API](https://github.com/afollestad/bridge#request-conversion-api)\r\n2. [Response Conversion](https://github.com/afollestad/bridge#response-conversion)\r\n\t1. [JSON Response Conversion](https://github.com/afollestad/bridge#json-response-conversion)\r\n\t2. [Dot Notation](https://github.com/afollestad/bridge#dot-notation-1)\r\n\t3. [Response Conversion API](https://github.com/afollestad/bridge#response-conversion-api)\r\n\r\n---\r\n\r\n# Gradle Dependency\r\n\r\n[ ![JitPack](https://img.shields.io/github/release/afollestad/bridge.svg?label=bridge) ](https://jitpack.io/#afollestad/bridge)\r\n[![Build Status](https://travis-ci.org/afollestad/bridge.svg)](https://travis-ci.org/afollestad/bridge)\r\n\r\n### Repository\r\n\r\nAdd this in your root `build.gradle` file (**not** your module `build.gradle` file):\r\n\r\n```gradle\r\nallprojects {\r\n\trepositories {\r\n\t\t...\r\n\t\tmaven { url \"https://jitpack.io\" }\r\n\t}\r\n}\r\n```\r\n\r\n### Dependency\r\n\r\nAdd this to your module's `build.gradle` file:\r\n\r\n```gradle\r\ndependencies {\r\n\t...\r\n\tcompile 'com.github.afollestad:bridge:3.1.0'\r\n}\r\n```\r\n\r\n---\r\n\r\n# Requests\r\n\r\nThe request API in Bridge is very easy to use. \r\n\r\n### Request Basics\r\n\r\nThe code below will request Google's homepage:\r\n\r\n```java\r\nRequest request = Bridge\r\n\t.get(\"https://www.google.com\")\r\n\t.request();\r\n```\r\n\r\n---\r\n\r\nBridge allows you to pass format args into request URLs (this applies to `get()`, `post()`, `put()`, `delete()`, etc.):\r\n\r\n```java\r\nRequest request = Bridge\r\n\t.get(\"https://www.google.com/search?q=%s\", searchQuery)\r\n\t.request();\r\n```\r\n\r\nThere are two advantages to doing this when your requests require query parameters: \r\ncode readability is improved, no string. concatenation is necessary. The contents of\r\nthe `searchQuery` variable are automatically URL encoded for you, e.g spaces are \r\nreplaced with `%20`.\r\n\r\n### Request Headers\r\n\r\nAdding or changing request headers is pretty simple:\r\n\r\n```java\r\nRequest request = Bridge\r\n\t.get(\"https://www.google.com\")\r\n\t.header(\"User-Agent\", \"My App!\")\r\n\t.header(\"CustomHeader\", \"HelloWorld\")\r\n\t.request();\r\n```\r\n\r\nIf you had the need to do so, you could also set a Map of headers with\r\nthe `headers(Map<String, Object>)` method.\r\n\r\n**Note**: the [Configuration](https://github.com/afollestad/bridge#configuration)\r\ngoes over how you can set default headers for all requests.\r\n\r\n### Request Bodies\r\n\r\nA lot of networking libraries make request bodies a bit difficult. Bridge aims\r\nto make them easy.\r\n\r\n##### Plain Bodies\r\n\r\nA description shouldn't be necessary for this:\r\n\r\n```java\r\nString postContent = \"Hello, how are you?\";\r\nRequest request = Bridge\r\n    .post(\"https://someurl.com/post.js\")\r\n    .body(postContent)\r\n\t.request();\r\n```\r\n\r\nIn addition to passing a `String`, other types of \"plain\" bodies include:\r\n\r\n* byte[]\r\n* JSONObject\r\n* JSONArray \r\n\r\nThere are other types of bodies discussed in the next few sections, along with \r\nin the [Request Conversion](https://github.com/afollestad/bridge#request-conversion)\r\nsection at the bottom (which is a bit more advanced).\r\n\r\n##### Form Bodies\r\n\r\n`Form`'s are commonly used with PUT/POST requests. They're basically the same \r\nthing as query strings with get requests, but the parameters are included in \r\nthe body of the request rather than the URL.\r\n\r\n```java\r\nForm form = new Form()\r\n    .add(\"Username\", \"Aidan\")\r\n    .add(\"Password\", \"Hello\");\r\nRequest request = Bridge\r\n    .post(\"https://someurl.com/login.js\")\r\n    .body(form)\r\n\t.request();\r\n```\r\n\r\n##### MultipartForm Bodies\r\n\r\nA `MultipartForm` is a bit different than a regular form. Content is added as \r\na \"part\" to the request body. The content is included as raw data associated with \r\na content type, allowing you to include entire files. Multipart forms are commonly \r\nused in HTML forms (e.g. a contact form on a website), and they can be used for \r\nuploading files to a website.\r\n\r\n```java\r\nMultipartForm form = new MultipartForm()\r\n    .add(\"Subject\", \"Hello\")\r\n    .add(\"Body\", \"Hey, how are you?\")\r\n    .add(\"FileUpload\", new File(\"/sdcard/Download/ToUpload.txt\"))\r\n    .add(\"FileUpload2\", \"ToUpload2.mp4\", Pipe.forFile(new File(\"/sdcard/Download/ToUpload2.mp4\")));\r\nRequest request = Bridge\r\n    .post(\"https://someurl.com/post.js\")\r\n    .body(form)\r\n    .request();\r\n```\r\n\r\nThis will automatically set the `Content-Type` header to `multipart/form-data`.\r\n\r\n**Note**: `MultipartForm` has an `add()` method that accepts a `Pipe`. This can \r\nbe used to add parts from streams (see the section below on how `Pipe` is used). \r\n`add()` for `File` objects is actually using this indirectly for you.\r\n\r\n##### Streaming Bodies\r\n\r\nBridge's `Pipe` API allows you to easily stream data directly into a post body.\r\n\r\n```java\r\nPipe pipe = new Pipe() {\r\n    byte[] content = \"Hello, this is a streaming example\".getBytes();\r\n\r\n    @Override\r\n    public void writeTo(@NonNull OutputStream os, @Nullable ProgressCallback progressListener) throws IOException {\r\n        os.write(content);\r\n        // Notify optional progress listener that all data was transferred\r\n        if (progressListener != null)\r\n            progressListener.publishProgress(content.length, content.length);\r\n    }\r\n\r\n    @NonNull\r\n    @Override\r\n    public String contentType() {\r\n        return \"text/plain\";\r\n    }\r\n\r\n    @Override\r\n    public int contentLength() throws IOException {\r\n        return content.length;\r\n    }\r\n};\r\n\r\nRequest request = Bridge\r\n    .post(\"https://someurl.com/post.js\")\r\n    .body(pipe)\r\n    .request();\r\n```\r\n\r\n**Note**: the value returned for `contentType()` in the `Pipe` is automatically set\r\nto the value of the associated header. You can override that by changing the header \r\nafter the body is set.\r\n\r\n`Pipe` has three static convenience methods that create a pre-built `Pipe` instance\r\nfor certain uses:\r\n\r\n```java\r\nPipe uriPipe = Pipe.forUri(this, Uri.parse(\r\n    \"content://com.example.provider/documents/images/1\"));\r\n\r\nPipe filePipe = Pipe.forFile(new File(\"/sdcard/myfile.txt\"));\r\n\r\nInputStream is = // ...\r\nPipe transferPipe = Pipe.forStream(is, \"text/plain\");\r\n```\r\n\r\nThey should be mostly self-explanatory.\r\n\r\n### Info Callbacks\r\n\r\nYou can set an info callback to receive various events, including a \r\nconnection being established, and request bodies being sent:\r\n\r\n```java\r\nRequest request = Bridge\r\n    .get(\"https://www.google.com\")\r\n    .infoCallback(new InfoCallback() {\r\n        @Override\r\n        public void onConnected(Request request) {\r\n            // Connection to Google established\r\n        }\r\n\r\n        @Override\r\n        public void onRequestSent(Request request) {\r\n            // This method is optional to override\r\n            // Indicates request body was sent to Google\r\n        }\r\n    }).request();\r\n```\r\n\r\nIt's likely that more will be added to this later.\r\n\r\n---\r\n\r\n# Responses\r\n\r\nLike requests, Bridge intends to make response interaction super easy.\r\n\r\n### Response Basics\r\n\r\nThe code below should be mostly self explanatory:\r\n\r\n```java\r\nRequest request = Bridge\r\n\t.get(\"https://www.google.com\")\r\n\t.request();\r\n\t\r\nResponse response = request.response();\r\nif (response.isSuccessful()) {\r\n\t// Request returned HTTP status 200-300\r\n} else {\r\n\t// Request returned an HTTP error status\r\n}\r\n```\r\n\r\nYou can also have Bridge throw an Exception in the event that `isSuccessful()`\r\nreturns false:\r\n\r\n```java\r\ntry {\r\n\tRequest request  = Bridge\r\n\t\t.get(\"https://www.google.com\")\r\n\t\t.throwIfNotSuccess()\r\n\t\t.request();\r\n\tResponse response = request.response();\r\n\t// Use successful response\r\n} catch(BridgeException e) {\r\n\t// See the error handling section\r\n}\r\n```\r\n\r\nIf you don't need a reference to the `Request` object, you can immediately retrieve the `Response`:\r\n\r\n```java\r\nResponse response = Bridge\r\n\t.get(\"https://www.google.com\")\r\n\t.response();\r\n```\r\n\r\n---\r\n\r\nYou can retrieve response headers similar to how request headers are set:\r\n\r\n```java\r\nResponse response = // ...\r\nString headerValue = response.header(\"Header-Name\");\r\n```\r\n\r\nHeaders can also have multiple values, separated by commas:\r\n\r\n```java\r\nResponse response = // ...\r\nList<String> values = response.headerList(\"Header-Name\");\r\n```\r\n\r\nYou can even retrieve the full map of headers:\r\n\r\n```java\r\nResponse response = // ...\r\nMap<String, List<String>> headers = response.headers();\r\n```\r\n\r\nSince *Content-Type* and *Content-Length* are commonly used response headers,\r\nthere's two convenience methods for these values:\r\n\r\n```java\r\nResponse response = // ...\r\nString contentType = response.contentType();\r\nint contentLength = response.contentLength();\r\n```\r\n\r\n### Response Bodies\r\n\r\nBridge includes many methods to make converting responses to object types you need\r\neasy. The code below should be self-explanatory:\r\n\r\n```java\r\nResponse response = // ...\r\n\r\nbyte[] responseRawData = response.asBytes();\r\n\r\n// Converts asBytes() to a UTF-8 encoded String.\r\nString responseString = response.asString();\r\n\r\n// If you set this to a TextView, it will display HTML formatting\r\nSpanned responseHtml = response.asHtml();\r\n\r\n// Cached in the Response object, using this method multiples will reference the same JSONObject.\r\n// This allows your app to not re-parse the JSON if it's used multiple times.\r\nJSONObject responseJsonObject = response.asJsonObject();\r\n\r\n// Cached in the Response object, using this method multiples will reference the same JSONArray.\r\n// This allows your app to not re-parse the JSON if it's used multiple times.\r\nJSONArray responseJsonArray = response.asJsonArray();\r\n\r\n// Don't forget to recycle!\r\n// Once you use this method once, the resulting Bitmap is cached in the Response object,\r\n// Meaning asBitmap() will always return the same Bitmap from any reference to this response.\r\nBitmap responseImage = response.asBitmap();\r\n\r\n// Save the response content to a File of your choosing\r\nresponse.asFile(new File(\"/sdcard/Download.extension\"));\r\n\r\n// Returns String, Spanned (for HTML), JSONObject, JSONArray, Bitmap, or byte[]\r\n// based on the Content-Type header.\r\nObject suggested = response.asSuggested();\r\n```\r\n\r\nIf you're not interested in using the `Request` or `Response` object during\r\nrequests, you can immediately retrieve the response body:\r\n\r\n```java\r\nString responseBody = Bridge\r\n\t.get(\"https://www.google.com\")\r\n\t.asString();\r\n```\r\n\r\n`asString()` could be replaced with any of the body conversion methods above.\r\nUsing this will automatically use `throwIfNotSuccessful()`, so a `BridgeException`\r\nis thrown in case that the HTTP status code is not 200-300.\r\n\r\n---\r\n\r\n# Error Handling\r\n\r\nThe `BridgeException` class is used throughout the library and acts as a single \r\nexception provider. This helps avoid the need for different exception classes, \r\nor very unspecific Exceptions.\r\n\r\nIf you wanted, you could just display errors to the user using `BridgeException#getMessage()`. \r\nHowever, `BridgeException` lets you know exactly what happened before the user \r\nsees anything.\r\n\r\n---\r\n\r\nThe `BridgeException#reason()` method returns a constants that indicate why the exception \r\nwas thrown. If the Exception is for a request, you can retrieve the `Request` with \r\n`BridgeException#request()`. If the `Exception` is for a response, you can retrieve the \r\n`Response` with `BridgeException#response()`.\r\n\r\n```java\r\nBridgeException e = // ...\r\nswitch (e.reason()) {\r\n    case BridgeException.REASON_REQUEST_CANCELLED: {\r\n        Request request = e.request();\r\n        // Used in BridgeExceptions passed to async request callbacks\r\n        // when the associated request was cancelled.\r\n        break;\r\n    }\r\n    case BridgeException.REASON_REQUEST_TIMEOUT: {\r\n        Request request = e.request();\r\n        // The request timed out (self explanatory obviously)\r\n        break;\r\n    }\r\n    case BridgeException.REASON_REQUEST_FAILED: {\r\n        Request request = e.request();\r\n        // Thrown when a general networking error occurs during a request,\r\n        // not including timeouts.\r\n        break;\r\n    }\r\n    case BridgeException.REASON_RESPONSE_UNSUCCESSFUL: {\r\n        Response response = e.response();\r\n        // Thrown by throwIfNotSuccess(), when you explicitly want an\r\n        // Exception be thrown if the status code was unsuccessful.\r\n        break;\r\n    }\r\n    case BridgeException.REASON_RESPONSE_UNPARSEABLE: {\r\n        Response response = e.response();\r\n        // Thrown by the response conversion methods (e.g. asJsonObject())\r\n        // When the response content can't be successfully returned in the\r\n        // requested format. E.g. a JSON error.\r\n        break;\r\n    }\r\n    case BridgeException.REASON_RESPONSE_IOERROR: {\r\n        Response response = e.response();\r\n        // Thrown by the asFile() response converter when the library\r\n        // is unable to save the content to a file.\r\n        break;\r\n    }\r\n    case BridgeException.REASON_RESPONSE_VALIDATOR_FALSE:\r\n    case BridgeException.REASON_RESPONSE_VALIDATOR_ERROR:\r\n        String validatorId = e.validatorId();\r\n        // Discussed in the Validators section\r\n        break;\r\n}\r\n```\r\n\r\n**Note**: you do not need to handle all of these cases everywhere a `BridgeException` \r\nis thrown. The comments within the above example code indicate where those reasons are generally used.\r\n\r\n---\r\n\r\n# Async\r\n\r\nUp until now, all code has been syncronous, meaning it gets run on the calling thread.\r\nAndroid does not allow you to perform networking options on the UI thread, for good reasons.\r\nAsyncronous requests become very important when you don't want to handle threading yourself.\r\nPlus, Bridge comes with some huge advantages when using async methods.\r\n\r\n### Async Requests\r\n\r\nHere's a basic example of an async request. Obviously, `get()` can be replaced with the\r\nother HTTP methods such as `post()`.\r\n\r\n```java\r\nBridge\r\n\t.get(\"https://www.google.com\")\r\n\t.throwIfNotSuccess() // optional\r\n    .request(new Callback() {\r\n        @Override\r\n        public void response(Request request, Response response, BridgeException e) {\r\n            if (e != null) {\r\n                // See the 'Error Handling' section for information on how to process BridgeExceptions\r\n                int reason = e.reason();\r\n            } else {\r\n                // Use the Response object\r\n\t\t\t\tString responseContent = response.asString();\r\n            }\r\n        }\r\n    });\r\n```\r\n\r\nLike syncronous requests, there are shortcuts to response conversion:\r\n\r\n```java\r\nBridge\r\n\t.get(\"http://www.google.com\")\r\n    .asString(new ResponseConvertCallback<String>() {\r\n        @Override\r\n        public void onResponse(@NonNull Response response, @Nullable String object, @Nullable BridgeException e) {\r\n            if (e != null) {\r\n                // See the 'Error Handling' section for information on how to process BridgeExceptions\r\n                int reason = e.reason();\r\n            } else {\r\n                // Use object parameter\r\n            }\r\n        }\r\n    });\r\n```\r\n\r\nNot only is the calling thread *not* blocked, duplicate avoidance also comes \r\ninto the picture (see the section below).\r\n\r\n### Duplicate Avoidance\r\n\r\nDuplicate avoidance is a feature of Bridge which allows you to avoid making multiple\r\nrequests to a URL at the same time.\r\n\r\n```java\r\nBridge.get(\"http://www.google.com\")\r\n    .request(new Callback() {\r\n        @Override\r\n        public void response(Request request, Response response, BridgeException e) {\r\n            // Use error or response\r\n        }\r\n    });\r\nBridge.get(\"http://www.google.com\")\r\n    .request(new Callback() {\r\n        @Override\r\n        public void response(Request request, Response response, BridgeException e) {\r\n            // Use error or response\r\n        }\r\n    });\r\n```\r\n\r\nThe above code requests Google's homepage in rapid succession. Since the first request\r\nwill most likely not finish before the computer has a chance to begin requesting the second,\r\nBridge will pool these requests together. The second request does not get exectued, instead, \r\nit waits for the first to finish executing, and returns the response to both callbacks at the same time.\r\n\r\nThere is no limit to how many requests can be pooled. Bridge's sample project requests an entire\r\npage of images, but the image is only downloaded once.\r\n\r\n### Upload Progress\r\n\r\nUpload progress is pretty straight forward:\r\n\r\n```java\r\nBridge\r\n    .post(\"https://someurl.com/upload.js\")\r\n    .body(Pipe.forUri(this, data.getData()))\r\n    .uploadProgress(new ProgressCallback() {\r\n        @Override\r\n        public void progress(Request request, int current, int total, int percent) {\r\n            // Use progress\r\n        }\r\n    })\r\n    .request(new Callback() {\r\n        @Override\r\n        public void response(Request request, Response response, BridgeException e) {\r\n            // Use response\r\n        }\r\n    });\r\n```\r\n\r\n### Download Progress\r\n\r\nThe callback used to receive asyncronous request results has an optional `progress` method\r\nthat can be overidden in your callback:\r\n\r\n```java\r\nBridge\r\n    .get(\"http://someurl.com/bigfile.extension\")\r\n    .request(new Callback() {\r\n        @Override\r\n        public void response(Request request, Response response, BridgeException e) {\r\n            // Use Response or error\r\n        }\r\n\r\n        @Override\r\n        public void progress(Request request, int current, int total, int percent) {\r\n            // Progress updates\r\n        }\r\n    });\r\n```\r\n\r\n**Note**: progress callbacks are only used if the library is able to deetermine the size \r\nof the content being downloaded. Generally, this means the requested URL needs to return a \r\nvalue for the *Content-Length* header. When it comes to `Pipe`'s, the `Pipe` handles reporting\r\nprogress to the progress callback on its own.\r\n\r\n---\r\n\r\n# Request Cancellation\r\n\r\nRequest cancellation is another cool feature that Bridge specializes in.\r\nNote that it only works with asyncronous requests, syncronous requests\r\ncan't be cancelled since they can block the main thread.\r\n\r\n### Cancelling Single Requests\r\n\r\nThe `Request` object has a simple `cancel()` method:\r\n\r\n```java\r\nRequest request = Bridge\r\n    .get(\"https://www.google.com\")\r\n    .request(new Callback() {\r\n        @Override\r\n        public void response(Request request, Response response, BridgeException e) {\r\n            // Use error or response\r\n        }\r\n    });\r\nrequest.cancel();\r\n````\r\n\r\nWhen the request is cancelled, the callback receives a `BridgeException`. `reason()` will\r\nreturn `BridgeException.REASON_REQUEST_CANCELLED`. Most apps will probably ignore the error \r\nin this case.\r\n\r\n### Cancelling Multiple Requests\r\n\r\nThe `Bridge` class allows you to cancel multiple (or all) active async requests.\r\n\r\n##### All Active\r\n\r\nThis code will cancel all active requests, regardless of method or URL:\r\n\r\n```java\r\nBridge.cancelAll().commit();\r\n```\r\n\r\n##### Method, URL/Regex\r\n\r\nYou can even cancel all active requests that match an HTTP method and a URL or regular expression pattern.\r\n\r\nThis will cancel all GET requests to any URL starting with http:// and ending with .png:\r\n\r\n```java\r\nint count = Bridge.cancelAll()\r\n    .method(Method.GET)\r\n    .url(\"http://.*\\\\.png\")\r\n    .commit();\r\n```\r\n\r\n`.*` is a wildcard in regular expressions, `\\\\` escapes the period to make it literal.\r\n\r\nIf you want to cancel all requests to a specific URL, you can use `Pattern.quote()` to specify a regex that matches literal text:\r\n\r\n```java\r\nint count = Bridge.cancelAll()\r\n    .method(Method.GET)\r\n    .url(Pattern.quote(\"http://www.android.com/media/android_vector.jpg\"))\r\n    .commit();\r\n```\r\n\r\n##### Tags\r\n\r\nWhen making a request, you can tag it with a value (of any type):\r\n\r\n```java\r\nBridge.get(\"http://www.google.com\")\r\n    .tag(\"Hello!\")\r\n    .request(new Callback() {\r\n        @Override\r\n        public void response(Request request, Response response, BridgeException e) {\r\n            // Use response or error\r\n        }\r\n    });\r\n```\r\n\r\nYou can then cancel all requests which have that tag:\r\n\r\n```java\r\nBridge.cancelAll()\r\n    .tag(\"Hello!\")\r\n    .commit();\r\n```\r\n\r\n### Preventing Cancellation\r\n\r\nThere are certain situations in which you wouldn't want to allow a request to be cancelled. \r\nFor an example, your app may make calls to `Bridge.cancelAll().commit()` when an `Activity` pauses; \r\nthat way, all requests that were active in that screen are cancelled. However, there may be a \r\n`Service` in your app that's making requests in the background that you would want to maintain. \r\nYou can make those requests non-cancellable:\r\n\r\n```java\r\nBridge.get(\"http://www.google.com\")\r\n    .cancellable(false)\r\n    .request(new Callback() {\r\n        @Override\r\n        public void response(Request request, Response response, BridgeException e) {\r\n            // Use response or error\r\n        }\r\n    });\r\n```\r\n\r\nThis request will be ignored by `Bridge.cancelAll()` unless cancellation is forced:\r\n\r\n```java\r\nBridge.cancelAll()\r\n    .force()\r\n    .commit();\r\n```\r\n\r\n---\r\n\r\n# Validation\r\n\r\nValidators allow you to provide consistent checking that certain conditions are true for a response.\r\n\r\n```java\r\nResponseValidator validator = new ResponseValidator() {\r\n    @Override\r\n    public boolean validate(@NonNull Response response) throws Exception {\r\n        JSONObject json = response.asJsonObject();\r\n        return json.getBoolean(\"success\");\r\n    }\r\n\r\n    @NonNull\r\n    @Override\r\n    public String id() {\r\n        return \"custom-validator\";\r\n    }\r\n};\r\ntry {\r\n    JSONObject response = Bridge\r\n        .get(\"http://www.someurl.com/api/test\")\r\n        .validators(validator)\r\n        .asJsonObject();\r\n} catch (BridgeException e) {\r\n    if (e.reason() == BridgeException.REASON_RESPONSE_VALIDATOR_FALSE) {\r\n        String validatorId = e.validatorId();\r\n        // Validator returned false\r\n    } else if (e.reason() == BridgeException.REASON_RESPONSE_VALIDATOR_ERROR) {\r\n        String validatorId = e.validatorId();\r\n        String errorMessage = e.getMessage();\r\n        // Validator threw an error\r\n    }\r\n}\r\n```\r\n\r\nThe validator is passed before the request returns. Basically, the validator will check if a boolean \r\nfield in the response JSON called *success* is equal to true. If you had an API on a server that returned \r\ntrue or false for this value, you could automatically check if it's true for every request with a single validator.\r\n\r\nYou can even use multiple validators for a single request:\r\n\r\n```java\r\nResponseValidator validatorOne = // ...\r\nResponseValidator validatorTwo = // ...\r\n\r\ntry {\r\n    JSONObject response = Bridge\r\n        .get(\"http://www.someurl.com/api/test\")\r\n        .validators(validatorOne, validatorTwo)\r\n        .asJsonObject();\r\n} catch (BridgeException e) {\r\n    if (e.reason() == BridgeException.REASON_RESPONSE_VALIDATOR_FALSE) {\r\n        String validatorId = e.validatorId();\r\n        // Validator returned false\r\n    } else if (e.reason() == BridgeException.REASON_RESPONSE_VALIDATOR_ERROR) {\r\n        String validatorId = e.validatorId();\r\n        String errorMessage = e.getMessage();\r\n        // Validator threw an error\r\n    }\r\n}\r\n```\r\n\r\n**Notes**: validators work great with async requests too! You can even apply validators\r\nto every request in your application by setting global validators (discussed below).\r\n\r\n---\r\n\r\n# Configuration\r\n\r\nBridge allows you to set various parameters that are maintained\r\nas long as your app stays in memory.\r\n\r\n### Host Configuration\r\n\r\nYou can set a host that is used as the base URL for every request.\r\n\r\n```java\r\nBridge.config()\r\n    .host(\"http://www.google.com\");\r\n```\r\n\r\nWith Google's homepage set as the host, the code below would request `http://www.google.com/search?q=Hello`:\r\n\r\n```java\r\nBridge\r\n    .get(\"/search?q=%s\", \"Hello\")\r\n    .asString();\r\n```\r\n\t\r\nBasically, the URL you pass with each request is appended to the end of the host. If you were to pass a full URL \r\n(beginning with HTTP) in `get()` above, it would skip using the host for just that request.\r\n\r\n### Default Headers\r\n\r\nDefault headers are headers that are automatically applied to every request. You don't have to do it yourself with every request in your app.\r\n\r\n```java\r\nBridge.config()\r\n    .defaultHeader(\"User-Agent\", \"Bridge Sample Code\")\r\n    .defaultHeader(\"Content-Type\", \"application/json\")\r\n    .defaultHeader(\"Via\", \"My App\");\r\n```\r\n\r\nEvery request, regardless of the method, will include those headers. You can override them at the individual request level by setting the header as you normally would.\r\n\r\n### Timeout Configuration\r\n\r\nYou can configure how long the library will wait until timing out, either for connections or reading:\r\n\r\n```java\r\nBridge.config()\r\n    .connectTimeout(10000)\r\n    .readTimeout(15000);\r\n```\r\n\r\nYou can set timeouts at the request level too:\r\n\r\n```java\r\nBridge.get(\"http://someurl.com/bigVideo.mp4\")\r\n    .connectTimeout(10000)\r\n    .readTimeout(15000)\r\n    .request();\r\n```\r\n\r\n### Buffer Size\r\n\r\nThe default buffer size is 1024 * 4 (4096). Basically, when you download a webpage or file, the buffer size is how big the byte array is with each pass. A large buffer size will create a larger byte array, which can affect memory usage, but it also increases the pace in which the content is downloaded.\r\n\r\nThe buffer size can easily be configured:\r\n\r\n```java\r\nBridge.config()\r\n    .bufferSize(1024 * 10);\r\n```\r\n\r\nJust remember to be careful with how much memory you consume, and test on various devices. \r\nYou can set the buffer size at the request level too:\r\n\r\n```java\r\nBridge.get(\"http://someurl.com/bigVideo.mp4\")\r\n    .bufferSize(1024 * 10)\r\n    .response();\r\n```\r\n\r\n**Note**: the buffer size is used in a few other places, such as pre-built Pipe's (Pipe#forUri, Pipe#forStream, etc.).\r\n\r\n### Logging\r\n\r\nBy default, logging is disabled. You can enable logging to see what the library is doing in your Logcat:\r\n\r\n```java\r\nBridge.config()\r\n    .logging(true);\r\n```\r\n\r\n### Global Validators\r\n\r\nValidators for individual requests were shown above. You can apply validators to every request in your application:\r\n\r\n```java\r\nBridge.config()\r\n    .validators(new ResponseValidator() {\r\n        @Override\r\n        public boolean validate(@NonNull Response response) throws Exception {\r\n            JSONObject json = response.asJsonObject();\r\n            return json.getBoolean(\"success\");\r\n        }\r\n\r\n        @NonNull\r\n        @Override\r\n        public String id() {\r\n            return \"custom-validator\";\r\n        }\r\n    });\r\n```\r\n\r\n**Note**: you can pass multiple validators into the `validators()` method just like the individual request version.\r\n\r\n---\r\n\r\n# Cleanup\r\n\r\nWhen you're done with Bridge (e.g. your app is terminating), you should call the `destroy()` method to avoid any memory leaks. Your app would be fine without this, but this is good practice and it helps speed up Java's garbage collection.\r\n\r\n```java\r\nBridge.destroy();\r\n```\r\n\r\n**Note**: Calling this method will also cancel all active requests for you.\r\n\r\n---\r\n\r\n# Request Conversion\r\n\r\nBridge's request conversion feature allows you to use Java object instances directly as a request body. \r\nObjects are serialized directly into a format such as JSON.\r\n\r\n### JSON Request Conversion\r\n\r\nTake this class for an example:\r\n\r\n```java\r\n@ContentType(\"application/json\")\r\npublic class Person {\r\n\r\n    public Person() {\r\n    }\r\n\r\n    public Person(String name, int age) {\r\n        this.name = name;\r\n        this.age = age;\r\n    }\r\n\r\n    @Header(name = \"Custom-Header\")\r\n    public String customHeader;\r\n\r\n    @Body(name = \"full_name\")\r\n    public String name;\r\n    @Body\r\n    public int age;\r\n    @Body\r\n    public Person spouse;   \r\n}\r\n```\r\n\r\nThe `ContentType` annotation is used to lookup what request converter should be used. The annotation's value\r\nalso gets applied as the `Content-Type` header of requests the object is passed in to.\r\n\r\nThe `Header` annotation can be used to apply request header values.\r\n\r\nThe `Body` annotations indicate fields that are serialized into the response body. The optional name\r\nparameter can be used if the output name of the field should be different than the actual name of the field.\r\n\r\nYou can use instances of this class as a request body. Fields not marked with the `Header` or `Body`\r\nannotation are ignored.\r\n\r\n```java\r\nPerson person = new Person(\"Aidan Follestad\", 20);\r\nperson.girlfriend = new Person(\"Waverly Moua\", 18);\r\nRequest request = Bridge\r\n    .post(\"https://someurl.com/post.js\")\r\n    .body(person)\r\n    .request();\r\n```\r\n\r\nYou can even send arrays or lists of this object as a request body (and it gets converted to a JSON Array):\r\n\r\n```java\r\nPerson[] people = new People[] {\r\n    new Person(\"Aidan Follestad\", 20),\r\n    new Person(\"Waverly Moua\", 18)\r\n};\r\nRequest request = Bridge\r\n    .post(\"https://someurl.com/post.js\")\r\n    .body(people)\r\n    .request();\r\n```\r\n\r\n### Dot Notation\r\n\r\nI thought this was worthy of its own section. Bridge supports dot notation, which is better explained by example. \r\nTake this class:\r\n\r\n```java\r\n@ContentType(\"application/json\")\r\npublic static class Person {\r\n\r\n    public Person() {\r\n    }\r\n\r\n    public Person(String name, int age) {\r\n        this.name = name;\r\n        this.age = age;\r\n    }\r\n\r\n    @Body(name = \"person.name\")\r\n    public String name = \"Aidan\";\r\n    @Body(name = \"person.age.$t\")\r\n    public int age = 20;\r\n}\r\n```\r\n\r\nWhen converted to JSON, it will appear like this:\r\n\r\n```json\r\n{\r\n    \"person\": {\r\n        \"name\": \"Aidan\",\r\n        \"age\": {\r\n            \"$t\": 20\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nThe dots in the names of the `Body` annotation parameters indicate a path of objects that it takes\r\nto reach the value.\r\n\r\n### Request Conversion API\r\n\r\nBridge comes stock with a JSON request converter, but the API is extensible for people like you.\r\n\r\nSee the [JsonRequestConverter](https://github.com/afollestad/bridge/blob/master/bridge/src/main/java/com/afollestad/bridge/conversion/JsonRequestConverter.java) \r\nsource code for an example of how a `RequestConverter` is made. It should come off as simple.\r\n\r\nWhen you have a custom converter made, you can register it to a Content-Type:\r\n\r\n```java\r\nBridge.config()\r\n    .requestConverter(\"application/json\", new JsonRequestConverter());\r\n```\r\n\r\n---\r\n\r\n# Response Conversion\r\n\r\nBridge's response conversion feature allows you convert responses directly to Java object instances. Objects\r\nare de-serialized from a format such as jSON.\r\n\r\n### JSON Response Conversion\r\n\r\nTake this class for an example (notice that the `ContentType` annotation is not used with response \r\nconversion, but it should be left there if you plan on using request conversion):\r\n\r\n```java\r\npublic class Person {\r\n\r\n    public Person() {\r\n    }\r\n\r\n    public Person(String name, int age) {\r\n        this.name = name;\r\n        this.age = age;\r\n    }\r\n\r\n    @Header(name = \"Custom-Header\")\r\n    public String customHeader;\r\n\r\n    @Body(name = \"full_name\")\r\n    public String name;\r\n    @Body\r\n    public int age;\r\n    @Body\r\n    public Person spouse;   \r\n}\r\n```\r\n\r\nImagine a URL that returns JSON like this:\r\n\r\n```json\r\n{\r\n    \"name\": \"Aidan Follestad\",\r\n    \"age\": 20,\r\n    \"spouse\": {\r\n        \"name\": \"Waverly Moua\",\r\n        \"age\": 18\r\n    }\r\n}\r\n```\r\n\r\nYou can retrieve that URL and convert the contents directly to a `Person` instance like this:\r\n\r\n```java\r\nBridge.get(\"https://www.someurl.com/person.json\")\r\n    .asClass(Person.class, new ResponseConvertCallback<Person>() {\r\n        @Override\r\n        public void onResponse(@NonNull Response response, @Nullable Person object, @Nullable BridgeException e) {\r\n            // Use response object\r\n        }\r\n    });\r\n```\r\n\r\nYou can even retrieve arrays of JSON:\r\n\r\n```json\r\n[\r\n    {\r\n        \"name\": \"Aidan Follestad\",\r\n        \"age\": 20,\r\n        \"spouse\": {\r\n            \"name\": \"Waverly Moua\",\r\n            \"age\": 18\r\n        }\r\n    },\r\n    {\r\n        \"name\": \"Waverly Moua\",\r\n        \"age\": 18\r\n    }\r\n]\r\n```\r\n\r\n```java\r\nBridge.get(\"https://www.someurl.com/person_array.json\")\r\n    .asClassArray(Person.class, new ResponseConvertCallback<Person[]>() {\r\n        @Override\r\n        public void onResponse(@NonNull Response response, @Nullable Person[] objects, @Nullable BridgeException e) {\r\n            // Use response objects\r\n        }\r\n    });\r\n```\r\n\r\n### Dot Notation\r\n\r\nSee [Dot Notation](https://github.com/afollestad/bridge#dot-notation) under the Request Conversion API\r\n for details. It works the same way here, just in reverse.\r\n\r\n### Response Conversion API\r\n\r\nBridge comes stock with a JSON response converter, but the API is extensible for people like you.\r\n\r\nSee the [JsonResponseConverter](https://github.com/afollestad/bridge/blob/master/bridge/src/main/java/com/afollestad/bridge/conversion/JsonResponseConverter.java) \r\nsource code for an example of how a `ResponseConverter` is made. It should come off as simple.\r\n\r\nWhen you have a custom converter made, you can register it to a Content-Type:\r\n\r\n```java\r\nBridge.config()\r\n    .responseConverter(\"application/json\", new JsonResponseConverter());\r\n```","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}